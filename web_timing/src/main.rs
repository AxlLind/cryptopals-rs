use std::sync::Mutex;
use std::time::Duration;
use actix_web::{get, web, App, HttpServer, Responder, HttpResponse};
use actix_web::rt::time::sleep;
use once_cell::sync::Lazy;
use serde::Deserialize;

// randomly generated bytes
const KEY: [u8; 32] = [0x58,0x94,0xac,0xa6,0x2f,0x80,0x2a,0x6f,0x87,0x66,0x07,0xbe,0x32,0xbe,0x9b,0x48,0x28,0x0f,0xdd,0x08,0xbd,0xc8,0xd5,0x38,0xca,0xc5,0x69,0x02,0xc4,0x95,0xf4,0x8e];
const SECRET_TXT: &[u8] = b"Secret password or something";
static SLEEP_DURATION: Lazy<Mutex<u64>> = Lazy::new(|| Mutex::new(0));

async fn insecure_compare(a: &[u8], b: &[u8]) -> bool {
  if a.len() != b.len() { return false }
  let duration = *SLEEP_DURATION.lock().unwrap();
  for (x,y) in a.iter().zip(b) {
    if x != y { return false }
    sleep(Duration::from_millis(duration)).await;
  }
  true
}

#[derive(Deserialize)]
struct Payload {
  file: String,
  signature: String,
}

#[get("/test")]
async fn index(payload: web::Query<Payload>) -> impl Responder {
  let Payload { signature, file } = payload.into_inner();
  if file != "secret.txt" {
    return HttpResponse::InternalServerError().finish();
  }
  let sha1_mac = cryptopals_rs::sha1::hmac(&KEY, &SECRET_TXT);
  let proposed_mac = cryptopals_rs::from_hex_str(&signature);
  if proposed_mac.is_none() {
    return HttpResponse::InternalServerError().finish();
  }
  if !insecure_compare(&sha1_mac, &proposed_mac.unwrap()).await {
    return HttpResponse::InternalServerError().finish();
  }
  HttpResponse::Ok().body(SECRET_TXT)
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
  let duration_ms = std::env::args()
    .skip(1)
    .next()
    .expect("Need 1 argument")
    .parse::<u64>()
    .expect("Invalid argument");
  println!("Server starting, ms={}", duration_ms);
  *SLEEP_DURATION.lock().unwrap() = duration_ms;

  HttpServer::new(|| App::new().service(index))
    .bind("127.0.0.1:9000")?
    .run()
    .await
}
